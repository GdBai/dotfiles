" G. Bai's .vimrc

let mapleader = " "
let maplocalleader = " "

if has('nvim')
  lua vim.g["system_name"] = vim.loop.os_uname().sysname
else
  if has('win32')
    let g:system_name = "Windows_NT"
  elseif has('macunix')
    let g:system_name = "Darwin"
  else
    let g:system_name = "Linux"
  endif
endif

if g:system_name ==# "Windows_NT"
  set nocompatible " Get out of vi compatible mode
endif

" Load local .vimrc files
set exrc
set secure

if !exists("*ReloadConfigs")
  function ReloadConfigs()
    :source ~/.vimrc
    if has('gui_running')
      if !has('gui_vimr')
        :source ~/.gvimrc
      else
        :source ~/.config/nvim/ginit.vim
      endif
    endif
  endfunction
  command! RC call ReloadConfigs()
endif

" Cursor
if has('nvim')
  augroup reset_nvim_cursor
    autocmd!
    autocmd VimEnter,VimResume * set guicursor=n-v-c-sm:block-blinkon100,i-ci-ve:ver25-blinkon100,r-cr-o:hor20-blinkon100
    autocmd VimLeave,VimSuspend * set guicursor=a:ver25-blinkon100
  augroup END
else
  if $TERM_PROGRAM ==# 'iTerm.app'
    let &t_SI = "\<Esc>]50;CursorShape=1;BlinkingCursorEnabled=1\x7"
    let &t_SR = "\<Esc>]50;CursorShape=2;BlinkingCursorEnabled=1\x7"
    let &t_EI = "\<Esc>]50;CursorShape=0;BlinkingCursorEnabled=1\x7"
    " Initialize cursor shape/color on startup
    augroup reset_iTerm_cursor_on_enter
      autocmd!
      "autocmd VimEnter * startinsert | stopinsert
      autocmd VimEnter * normal! :startinsert :stopinsert
      "autocmd VimEnter * :normal :startinsert :stopinsert
      autocmd VimEnter * redraw!
    augroup END
  else
    let &t_SI .= "\e[5 q" " SI = INSERT mode
    let &t_SR .= "\e[3 q" " SR = REPLACE mode
    let &t_EI .= "\e[1 q" " EI = NORMAL mode (ELSE)
    " Initialize cursor shape/color on startup
    augroup reset_cursor_on_enter
      autocmd!
      "autocmd VimEnter * startinsert | stopinsert
      autocmd VimEnter * normal! :startinsert :stopinsert
      "autocmd VimEnter * :normal :startinsert :stopinsert
      autocmd VimEnter * redraw!
    augroup END
  endif
  " Reset cursor when Vim exits:
  augroup reset_cursor_on_leave
    autocmd!
    autocmd VimLeave * silent !echo -ne "\033[5 q"
  augroup END
endif

" Spell
set spelllang=en_gb
set spellfile=~/.vim/spell/en.utf-8.add
augroup spell_setting
  autocmd!
  autocmd FileType tex setlocal spell
augroup END
augroup spellfiles
  autocmd!
  autocmd BufNewFile,BufRead *.tex setlocal spellfile+=~/.vim/spell/tex.utf-8.add
augroup END

" Color scheme
syntax enable
colorscheme slate
highlight Normal ctermbg=235
highlight StatusLine ctermfg=253
highlight StatusLineNC ctermfg=243
highlight Tabline ctermbg=239
highlight TablineFill ctermfg=243
highlight VertSplit ctermfg=235 ctermbg=243

" Prevent wrong bg color during rapid scrolling
if (!has('nvim') && &term =~ '^xterm' && &t_Co == 256)
  set t_ut= | set ttyscroll=1
endif

augroup highlighting_fix
  autocmd!
  " fix vim script user command syntax highlighting
  " (should be unnecessary when https://github.com/vim/vim/issues/6587 is fixed)
  autocmd Syntax vim syn match vimUsrCmd '^\s*\zs\u\%(\w*\)\@>(\@!'
augroup END

" Clipboard
if g:system_name ==# "Darwin"
  set clipboard=unnamed
  noremap <Leader>y "*y
  noremap <Leader>p "*p
elseif g:system_name ==# "Linux"
  set clipboard=unnamedplus
  noremap <Leader>y "+y
  noremap <Leader>p "+p
  if has('nvim')
    let g:clipboard = {
          \   'name': 'xsel_override',
          \   'copy': {
          \      '+': 'xsel --input --clipboard',
          \      '*': 'xsel --input --primary',
          \    },
          \   'paste': {
          \      '+': 'xsel --output --clipboard',
          \      '*': 'xsel --output --primary',
          \   },
          \   'cache_enabled': 1,
          \ }
  endif
endif

" Paste toggle
nnoremap <C-p> :set invpaste paste?<CR>
set pastetoggle=<C-p>

" Buffer
set hidden
" Close the current buffer and move to the previous one
" This replicates the idea of closing a tab
nnoremap <leader>bd :bp! \| bd #<CR>
" A function to skip QuickFix buffer
function! BSkipQuickFix(command)
  let start_buffer = bufnr('%')
  execute a:command
  while &buftype ==# 'quickfix' && bufnr('%') != start_buffer
    execute a:command
  endwhile
endfunction
" Move to next buffer
nnoremap <leader>bn :call BSkipQuickFix("bn!")<CR>
" Move to previous buffer
nnoremap <leader>bp :call BSkipQuickFix("bp!")<CR>

" Window shortcuts
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-h> <C-w>h
nnoremap <C-l> <C-w>l
nnoremap <C-q> <C-w>q

augroup quickfix_window_height
  autocmd!
  autocmd FileType qf call AdjustWindowHeight(3, 10)
augroup END
function! AdjustWindowHeight(minheight, maxheight)
  exe max([min([line("$"), a:maxheight]), a:minheight]) . "wincmd _"
endfunction

nnoremap <leader>hc :helpclose<CR>

if g:system_name ==# "Darwin"
  if has('nvim')
    let g:python_host_prog = '$HOME/.pyenv/versions/py2nvim/bin/python'
    let g:python3_host_prog = '$HOME/.pyenv/versions/py3nvim/bin/python'
  elseif has('python3_dynamic')
    "set pythonhome=$HOME/.pyenv/versions/2.7.18
    "set pythondll=$HOME/.pyenv/versions/2.7.18/lib/libpython2.7.dylib
    "set pythonthreehome=$HOME/.pyenv/versions/3.8.10
    "set pythonthreedll=$HOME/.pyenv/versions/3.8.10/lib/libpython3.8.dylib
    py3 1+2
    pyx 1+2
  endif
elseif g:system_name ==# "Linux"
  if has('nvim')
    let g:python3_host_prog = '$HOME/miniforge3/envs/py3nvim/bin/python'
  endif
endif

" Check if memory size is large enough to use plugins
if g:system_name ==# "Darwin"
  let g:flag = "good"
elseif g:system_name ==# "Linux"
  let mem_size = system("free -mt | tail -1 | awk '{print $2}'") " Get memory size in MB
  if mem_size > 3600
    let g:flag = "good"
  else
    let g:flag = "nogood"
  endif
endif

" Windows also works
if g:system_name ==# "Windows_NT"
  let g:flag = "good"
endif

if g:flag == "nogood"
  " Auto source .vimrc after saving
  augroup auto_source_vimrc
    autocmd!
    autocmd BufWritePost $MYVIMRC source $MYVIMRC
  augroup END
  let g:tex_comment_nospell = 1 " For vimtex use g:vimtex_syntax_nospell_comments
elseif g:flag == "good"
  " Auto source .vimrc and refresh vim-airline after saving
  augroup auto_source_vimrc_refresh_airline
    autocmd!
    autocmd BufWritePost $MYVIMRC source $MYVIMRC | call airline#extensions#tabline#buffers#invalidate() | AirlineRefresh
  augroup END
endif

let g:config_files = [
      \ 'misc.vim',
      \ 'plug.vim',
      \ 'theme.vim',
      \ ]
" 'theme.vim' must come after 'plug.vim'

for s:fname in g:config_files
  execute printf('source ~/.vim/core/%s', s:fname)
endfor
